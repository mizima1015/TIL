-- p.174 구매자 분석
USE INSTACART;
SELECT
	*
    , ROW_NUMBER() OVER(ORDER BY F DESC) RNK
FROM(
SELECT
	USER_ID
    , COUNT(DISTINCT ORDER_ID) AS F
FROM 
	ORDERS
GROUP BY 1
) A
;

SELECT COUNT(DISTINCT USER_ID)
FROM
(
	SELECT USER_ID
		, COUNT(DISTINCT ORDER_ID)
	FROM ORDERS
    GROUP BY 1
) A
;

-- 10분위 수 지정
SELECT
	*
    , CASE WHEN RNK <= 316 THEN 'QUANTILE_1' 
    WHEN RNK <= 632 THEN 'QUANTILE_2' 
    WHEN RNK <= 948 THEN 'QUANTILE_3' 
    WHEN RNK <= 1264 THEN 'QUANTILE_4' 
    WHEN RNK <= 1580 THEN 'QUANTILE_5' 
    WHEN RNK <= 1895 THEN 'QUANTILE_6' 
    WHEN RNK <= 2211 THEN 'QUANTILE_7' 
    WHEN RNK <= 2527 THEN 'QUANTILE_8' 
    WHEN RNK <= 2843 THEN 'QUANTILE_9' 
    WHEN RNK <= 3159 THEN 'QUANTILE_10' 
    END QUANTILE
FROM(
SELECT
	*
    , ROW_NUMBER() OVER(ORDER BY F DESC) RNK
FROM(
SELECT
	USER_ID
    , COUNT(DISTINCT ORDER_ID) AS F
FROM 
	ORDERS
GROUP BY 1
) A
) A
;

-- 테이블로 만들기
CREATE TEMPORARY TABLE USER_QUANTILE AS
SELECT
	*
    , CASE WHEN RNK <= 316 THEN 'QUANTILE_1' 
    WHEN RNK <= 632 THEN 'QUANTILE_2' 
    WHEN RNK <= 948 THEN 'QUANTILE_3' 
    WHEN RNK <= 1264 THEN 'QUANTILE_4' 
    WHEN RNK <= 1580 THEN 'QUANTILE_5' 
    WHEN RNK <= 1895 THEN 'QUANTILE_6' 
    WHEN RNK <= 2211 THEN 'QUANTILE_7' 
    WHEN RNK <= 2527 THEN 'QUANTILE_8' 
    WHEN RNK <= 2843 THEN 'QUANTILE_9' 
    WHEN RNK <= 3159 THEN 'QUANTILE_10' 
    END QUANTILE
FROM(
SELECT
	*
    , ROW_NUMBER() OVER(ORDER BY F DESC) RNK
FROM(
SELECT
	USER_ID
    , COUNT(DISTINCT ORDER_ID) AS F
FROM 
	ORDERS
GROUP BY 1
) A
) A
;

SELECT QUANTILE,
SUM(F) F
FROM USER_QUANTILE
GROUP BY 1;

-- 강사코드

SELECT 
	*, 
    CASE WHEN RNK <= (SELECT COUNT(DISTINCT user_id)
FROM 
	(SELECT 
		user_id
		, COUNT(DISTINCT order_id) F 
	 FROM orders
     GROUP BY 1
) A) / 10 THEN 'Quantile_1' 
WHEN RNK<=((SELECT COUNT(DISTINCT user_id)
FROM 
	(SELECT 
		user_id
		, COUNT(DISTINCT order_id) F 
	 FROM orders
     GROUP BY 1
) A)/10)*2 THEN 'Quantile_2'
END quantile
FROM (
	SELECT 
		*
		, ROW_NUMBER() OVER(ORDER BY F DESC) RNK
	FROM (
		SELECT 
			user_id
			, COUNT(DISTINCT order_id) AS F
		FROM 
			orders
		GROUP BY 1
	) A
) A 
;

SELECT *
FROM USER_QUANTILE;

-- 각 부위별 전체 주문 건수의 합을 구한다.
SELECT
	QUANTILE
    , SUM(F)
FROM user_QUANTILE
GROUP BY 1;

SELECT
	QUANTILE AS 분위수
    , SUM(F) AS 주문건수
    , SUM(F) / 3220 AS 비율
FROM USER_QUANTILE
GROUP BY 1;

-- P.181
-- 재구매 / 재방문 ==> 전환율
-- 테이블 : ORDER_PRODUCT__PRIOR

SELECT
	PRODUCT_ID
    , SUM(REORDERED)/SUM(1) AS REORDER_RATE
    , COUNT(DISTINCT ORDER_ID) AS F
FROM ORDER_PRODUCTS__PRIOR
GROUP BY PRODUCT_ID
ORDER BY REORDER_RATE DESC
;
SELECT
	A.PRODUCT_ID
    , SUM(REORDERED)/SUM(1) AS REORDER_RATE
    , COUNT(DISTINCT ORDER_ID) AS F
FROM ORDER_PRODUCTS__PRIOR A
LEFT
JOIN PRODUCTS B
ON A.PRODUCT_ID = B.PRODUCT_ID
GROUP BY PRODUCT_ID
HAVING COUNT(DISTINCT ORDER_ID) > 10
ORDER BY REORDER_RATE DESC
;

SELECT
	A.PRODUCT_ID
    , B.PRODUCT_NAME
    , SUM(REORDERED)/SUM(1) AS REORDER_RATE
    , COUNT(DISTINCT ORDER_ID) AS F
FROM ORDER_PRODUCTS__PRIOR A
LEFT
JOIN PRODUCTS B
ON A.PRODUCT_ID = B.PRODUCT_ID
GROUP BY PRODUCT_ID, B.PRODUCT_NAME
HAVING COUNT(DISTINCT ORDER_ID) > 10
ORDER BY REORDER_RATE DESC
;

-- 다음 구매까지의 소요기간과 재구매 관계
-- 일정 주기를 구하는 것은 평균을 구하는 것이다...?
-- 기초 통계로 적용하면?
-- 어떤 방법론을 적용하면 될까?
-- 두 그룹을 T-TEST
-- 기초통계 내용 공부 다시하기..
SELECT
	*
FROM(
SELECT
	*
    , ROW_NUMBER() OVER(ORDER BY RET_RATIO DESC) RNK
FROM(
SELECT
	PRODUCT_ID
    , SUM(REORDERED)/ COUNT(*) AS RET_RATIO
FROM ORDER_PRODUCTS__PRIOR
GROUP BY 1
) A
) A
;

CREATE TEMPORARY TABLE PRODUCT_REPURCHASE_QUANTILE AS
SELECT
	A.PRODUCT_ID
    , CASE WHEN RNK<= 929 THEN 'Q_1'
    WHEN RNK<= 1858 THEN 'Q_2'
    WHEN RNK<= 2786 THEN 'Q_3'
    WHEN RNK<= 3715 THEN 'Q_4'
    WHEN RNK<= 4644 THEN 'Q_5'
    WHEN RNK<= 5573 THEN 'Q_6'
    WHEN RNK<= 6502 THEN 'Q_7'
    WHEN RNK<= 7430 THEN 'Q_8'
    WHEN RNK<= 8359 THEN 'Q_9'
    WHEN RNK<= 9288 THEN 'Q_10'
    END RNK_GRP
FROM(
SELECT
	*
    , ROW_NUMBER() OVER(ORDER BY RET_RATIO DESC) RNK
FROM(
SELECT
	PRODUCT_ID
    , SUM(REORDERED)/ COUNT(*) AS RET_RATIO
FROM ORDER_PRODUCTS__PRIOR
GROUP BY 1
) A
) A
GROUP BY 1,2
;

-- P.188
-- 각 분위 수별 재구매 소요 기간의 분산을 구하려면 다음과 같은 정보를 결합해 구해야 함
-- 상품별 분위수 테이블
-- 주문 소요 시간 : ORDERS 테이블
-- 주문 번호 상품번호 : ORDER_PRODUCT__PRIOR

CREATE TEMPORARY TABLE ORDER_PRODUCT__PRIOR2 AS
SELECT
	PRODUCT_ID
    , DAYS_SINCE_PRIOR_ORDER
FROM ORDER_PRODUCTS__PRIOR A
INNER
JOIN ORDERS B
ON A.ORDER_ID = B.ORDER_ID
;

SELECT COUNT(*) FROM ORDER_PRODUCT__PRIOR2;

-- 분위수, 상품별 구매 소요 기간의 분산 계산 VARIANCE
SELECT
	A.RNK_GRP
    , A.PRODUCT_ID
    ,  VARIANCE(DAYS_SINCE_PRIOR_ORDER) AS VAR_DAYS
FROM PRODUCT_REPURCHASE_QUANTILE A
LEFT JOIN ORDER_PRODUCT__PRIOR2 B
ON A.PRODUCT_ID = B.PRODUCT_ID
GROUP BY 1,2
ORDER BY 1,2
;

-- 가정 : 재구매율이 높은 상품군은 구매 주기가 일정할 것이다!
-- 재구매율에 따라 상품ㅇ르 10가지 그룹으로 분할 했고, 각 분위 수의 상품별 구매 소요 기간의 분산을 계산했다.
-- MEDIAN 함수를 이용하겠다! (문제:MYSQL은 제공하지 않음)

-- 1) SQL에 함수가 존재하지 않음 ===> 사용자 정의 함수 (PL/SQL)
-- 2) PYTHON 또는 R이랑 연동해서, DB에서 PYTHON으로 데이터를 가져와서 통계처리
SELECT RNK_GRP,
AVG(VAR_DAYS) AVG_VAR_DAYS
FROM
(SELECT A.RNK_GRP,
A.PRODUCT_ID,
VARIANCE(days_since_prior_order) VAR_DAYS
FROM PRODUCT_REPURCHASE_QUANTILE A
LEFT
JOIN INSTACART.ORDER_PRODUCTS__PRIOR B
ON A.PRODUCT_ID = B.PRODUCT_ID
LEFT
JOIN INSTACART.ORDERS C
ON B.ORDER_ID = C.ORDER_ID
GROUP
BY 1,2) A
GROUP
BY 1
ORDER
BY 1
;

-- 분산분석
-- 3개 이상의 그룹 비교
-- P.VALUE 0.05 이하 ==> 대립가설 채택
-- 사후 분석 ==> 두개 그룹으로 쪼개서, 두 그룹간의 평균 비교
-- Q_1, VS Q_2 비교, Q_3 비교... Q_10
-- Q_2, VS Q_3 비교, Q_4 비교... Q_10
-- ...
-- Q_9 VS Q_10